package com.transaction.service.impl;

import com.transaction.analytics.service.model.*;
import com.transaction.analytics.service.model.CommonBean;
import com.transaction.common.constants.ChannelType;
import com.transaction.common.constants.ErrorCodeEnum;
import com.transaction.common.exception.*;
import com.transaction.common.util.ApplicationLogger;
import com.transaction.dto.*;
import com.transaction.service.TransactionAnalyticService;
import com.transaction.service.TransactionAnalyticsRetryFacade;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service implementation for processing and aggregating transaction analytics.
 */

@Service
@RequiredArgsConstructor
public class TransactionAnalyticServiceImpl implements TransactionAnalyticService {

    private static final ApplicationLogger logger = ApplicationLogger.getLogger(TransactionAnalyticServiceImpl.class);

    private final TransactionAnalyticsRetryFacade transactionAnalyticsRetryFacade;

    /**
     * Fetches transaction analytics data based on request criteria such as
     * date range, channel, merchant, and user role.
     *
     * @param txnAnalyticRequest request containing analytics filters
     * @param commonBean common request data
     * @return aggregated transaction analytics response
     */

    @Override
    public TxnAnalyticResponse fetchTransactionAnalytics(TxnAnalyticRequest txnAnalyticRequest, CommonBean commonBean) {

            String userRole = txnAnalyticRequest.getUserRole().getValue();
            LocalDateTime fromDateTime = txnAnalyticRequest.getFromDate().atStartOfDay();
            LocalDateTime toDateTime = txnAnalyticRequest.getToDate().atTime(23, 59, 59);

            if (fromDateTime.isAfter(toDateTime)) {
                throw new InvalidAnalyticsRequestException(ErrorCodeEnum.INVALID_DATE_RANGE.getErrorMessage());
            }

            List<Integer> merchantIdList = userRole.equalsIgnoreCase("RESELLER")
                    ? transactionAnalyticsRetryFacade.getMerchantsForReseller(commonBean.getSourceId(), commonBean.getSubSourceId())
                    : List.of(txnAnalyticRequest.getMerchId());

            if (merchantIdList == null || merchantIdList.isEmpty()) {
                throw new MerchantNotFoundException(ErrorCodeEnum.MERCHANT_NOT_FOUND.getErrorMessage());
            }

            logger.info("Fetched merchantId list {}", merchantIdList);

            String channelName = txnAnalyticRequest.getChannelName().getValue();
            TxnAnalyticResponse txnAnalyticResponse = new TxnAnalyticResponse();
            txnAnalyticResponse.setMerchId(txnAnalyticRequest.getMerchId());
            txnAnalyticResponse.setRequestorId(txnAnalyticRequest.getRequestorId());

            if (channelName.equalsIgnoreCase("ONLINE") || channelName.equalsIgnoreCase("QR")) {
                int channelId = channelName.equalsIgnoreCase("ONLINE") ? 1 : 4;
                txnAnalyticResponse = filterOnlineOrQRTransactions(txnAnalyticResponse,
                        txnAnalyticRequest, commonBean, channelId, merchantIdList, fromDateTime, toDateTime);
            } else {
                txnAnalyticResponse = filterPOSTransactions(txnAnalyticResponse, merchantIdList, fromDateTime, toDateTime);
            }

            return txnAnalyticResponse;
    }

    private TxnAnalyticResponse filterPOSTransactions(TxnAnalyticResponse txnAnalyticResponse, List<Integer> merchantIdList,
                                                      LocalDateTime fromDateTime, LocalDateTime toDateTime) {
        ArrayList<DayWiseTxnSummary> dayWiseTxnSummaries = new ArrayList<>();
        ArrayList<ProductWiseTxnSummary> productWiseTxnSummaries = new ArrayList<>();

        List<PosTransactionSummaryDTO> posTransactions =
                transactionAnalyticsRetryFacade.getPosTransactions(fromDateTime, toDateTime, merchantIdList);

        if (posTransactions.isEmpty()) {
            throw new TransactionNotFoundException(ErrorCodeEnum.TRANSACTIONS_NOT_FOUND.getErrorMessage());
        }

        List<String> products = posTransactions.stream()
                .map(txn -> txn.bankProduct() + "-" + txn.channelType())
                .distinct()
                .toList();

        List<PosTransactionSummaryDTO> successTransactionList =
                posTransactions.stream()
                        .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                        .toList();

        txnAnalyticResponse.setSuccessCount(successTransactionList.stream()
                .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                .reduce(0, Integer::sum));

        txnAnalyticResponse.setFailureCount(posTransactions.stream()
                .filter(txn -> Integer.valueOf(0).equals(txn.txnStatus()))
                .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                .reduce(0, Integer::sum));

        Map<LocalDate, List<PosTransactionSummaryDTO>> groupedByDate =
                posTransactions.stream()
                        .collect(Collectors.groupingBy(txn ->
                                txn.txnDate().toInstant()
                                        .atZone(ZoneId.systemDefault())
                                        .toLocalDate()
                        ));

        for (Map.Entry<LocalDate, List<PosTransactionSummaryDTO>> entry : groupedByDate.entrySet()) {
            LocalDate date = entry.getKey();
            List<PosTransactionSummaryDTO> dayWiseTransactionList = entry.getValue();

            int dayWiseSuccessCount = dayWiseTransactionList.stream()
                    .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                    .mapToInt(txn -> Optional.ofNullable(txn.count()).orElse(0L).intValue())
                    .sum();

            int dayWiseFailureCount = dayWiseTransactionList.stream()
                    .mapToInt(txn -> Optional.ofNullable(txn.count()).orElse(0L).intValue())
                    .sum() - dayWiseSuccessCount;

            DayWiseTxnSummary dayWiseTxnSummary = new DayWiseTxnSummary();
            dayWiseTxnSummary.setDate(date);
            dayWiseTxnSummary.setDayWiseSuccessCount(dayWiseSuccessCount);
            dayWiseTxnSummary.setDayWiseFailedCount(dayWiseFailureCount);

            dayWiseTxnSummaries.add(dayWiseTxnSummary);
        }

        txnAnalyticResponse.setDayWiseTxnSummary(dayWiseTxnSummaries);

        for (String product : products) {
            List<PosTransactionSummaryDTO> successTransactions =
                    posTransactions.stream()
                            .filter(txn -> ((txn.bankProduct() + "-" + txn.channelType()).equals(product)))
                            .toList();

            Integer successCount = successTransactions.stream()
                    .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                    .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                    .reduce(0, Integer::sum);

            ProductWiseTxnSummary productWiseTxnSummary = new ProductWiseTxnSummary();
            productWiseTxnSummary.setProductName(product.split("-")[0]);
            productWiseTxnSummary.setProductWiseSuccessCount(successCount);
            productWiseTxnSummaries.add(productWiseTxnSummary);
        }
        txnAnalyticResponse.setProductWiseTxnSummary(productWiseTxnSummaries);
        txnAnalyticResponse.setInitiatedCount(0);
        txnAnalyticResponse.setRevertedCount(0);
        txnAnalyticResponse.setAwaitedCount(0);

        return txnAnalyticResponse;

    }

    private TxnAnalyticResponse filterOnlineOrQRTransactions(TxnAnalyticResponse txnAnalyticResponse,
                                                             TxnAnalyticRequest txnAnalyticRequest, CommonBean commonBean, Integer channelId,
                                                             List<Integer> merchantIdList, LocalDateTime fromDateTime, LocalDateTime toDateTime) {

        ArrayList<DayWiseTxnSummary> dayWiseTxnSummaries = new ArrayList<>();
        ArrayList<ProductWiseTxnSummary> productWiseTxnSummaries = new ArrayList<>();

        List<OnlineQrTransactionSummaryDTO> onlineOrQrTransactions =
                transactionAnalyticsRetryFacade.getOnlineQrTransactions(fromDateTime, toDateTime, merchantIdList, channelId);

        if (onlineOrQrTransactions.isEmpty()) {
            throw new TransactionNotFoundException(ErrorCodeEnum.TRANSACTIONS_NOT_FOUND.getErrorMessage());
        }

        List<ChannelProductDTO> allProducts = transactionAnalyticsRetryFacade.getAllChannelProducts();
        Map<Integer, String> productMap = allProducts.stream()
                .collect(
                        Collectors.toMap(ChannelProductDTO::channelProdId, ChannelProductDTO::channelProdName)
                );

        List<String> products = onlineOrQrTransactions.stream()
                .map(
                        txn -> productMap.get(txn.channelProdId()) + "-" + ChannelType.fromId(txn.channelId())
                )
                .distinct()
                .toList();

        List<Integer> merchIdList =
                commonBean.getUserRole().getValue().equalsIgnoreCase("RESELLER")
                        ? merchantIdList
                        : List.of(txnAnalyticRequest.getMerchId());

        txnAnalyticResponse.setInitiatedCount(transactionAnalyticsRetryFacade.countInitiated(fromDateTime,
                toDateTime, merchIdList, channelId));

        txnAnalyticResponse.setAwaitedCount(transactionAnalyticsRetryFacade.countAttempted(fromDateTime,
                toDateTime, merchIdList, channelId));

        txnAnalyticResponse.setRevertedCount(transactionAnalyticsRetryFacade.countReverted(fromDateTime,
                toDateTime, merchIdList, channelId));

        List<OnlineQrTransactionSummaryDTO> successTransactionList =
                onlineOrQrTransactions.stream()
                        .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                        .toList();

        txnAnalyticResponse.setSuccessCount(successTransactionList.stream()
                .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                .reduce(0, Integer::sum));

        txnAnalyticResponse.setFailureCount(onlineOrQrTransactions.stream()
                .filter(txn -> Integer.valueOf(0).equals(txn.txnStatus()))
                .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                .reduce(0, Integer::sum));

        // Group transactions by LocalDate (ignoring time)
        Map<LocalDate, List<OnlineQrTransactionSummaryDTO>> groupedByDate =
                onlineOrQrTransactions.stream()
                        .collect(Collectors.groupingBy(txn ->
                                txn.txnDate().toInstant()
                                        .atZone(ZoneId.systemDefault())
                                        .toLocalDate()
                        ));

        for (Map.Entry<LocalDate, List<OnlineQrTransactionSummaryDTO>> entry : groupedByDate.entrySet()) {
            LocalDate date = entry.getKey();
            List<OnlineQrTransactionSummaryDTO> dayWiseTransactionList = entry.getValue();

            int dayWiseSuccessCount = dayWiseTransactionList.stream()
                    .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                    .mapToInt(txn -> Optional.ofNullable(txn.count()).orElse(0L).intValue())
                    .sum();

            int dayWiseFailureCount = dayWiseTransactionList.stream()
                    .mapToInt(txn -> Optional.ofNullable(txn.count()).orElse(0L).intValue())
                    .sum() - dayWiseSuccessCount;

            DayWiseTxnSummary dayWiseTxnSummary = new DayWiseTxnSummary();
            dayWiseTxnSummary.setDate(date);
            dayWiseTxnSummary.setDayWiseSuccessCount(dayWiseSuccessCount);
            dayWiseTxnSummary.setDayWiseFailedCount(dayWiseFailureCount);

            dayWiseTxnSummaries.add(dayWiseTxnSummary);
        }

        txnAnalyticResponse.setDayWiseTxnSummary(dayWiseTxnSummaries);

        for (String product : products) {
            List<OnlineQrTransactionSummaryDTO> successTransactions =
                    onlineOrQrTransactions.stream()
                            .filter(txn -> (productMap.get(txn.channelProdId()) + "-" + ChannelType.fromId(txn.channelId())).equals(product))
                            .toList();

            Integer successCount = successTransactions.stream()
                    .filter(txn -> Integer.valueOf(1).equals(txn.txnStatus()))
                    .map(entity -> Integer.valueOf(String.valueOf(entity.count())))
                    .reduce(0, Integer::sum);

            ProductWiseTxnSummary productWiseTxnSummary = new ProductWiseTxnSummary();
            productWiseTxnSummary.setProductName(product.split("-")[0]);
            productWiseTxnSummary.setProductWiseSuccessCount(successCount);
            productWiseTxnSummaries.add(productWiseTxnSummary);
        }
        txnAnalyticResponse.setProductWiseTxnSummary(productWiseTxnSummaries);

        return txnAnalyticResponse;

    }

}
