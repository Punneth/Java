package com.transaction.common.exception;

import com.transaction.analytics.service.model.ErrorResponse;
import com.transaction.common.messages.AppLogMessages;
import com.transaction.common.messages.ErrorMessages;
import com.transaction.common.util.ApplicationLogger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingRequestHeaderException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ResponseStatusException;

import java.util.stream.Collectors;

/**
 * Global exception handler for centralized error handling across all controllers.
 * Provides consistent error responses and logging.
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final ApplicationLogger logger = ApplicationLogger.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorResponse> handleInvalidJson(HttpMessageNotReadableException ex) {
        logger.error(AppLogMessages.VALIDATION_EXCEPTION, ex.getClass().getSimpleName(), ex);

        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage(ErrorMessages.VALIDATION_FAILED);
        errorResponse.setCode("VALIDATION_ERROR");

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    /**
     * Handles missing request header exceptions
     */
    @ExceptionHandler(MissingRequestHeaderException.class)
    public ResponseEntity<ErrorResponse> handleMissingRequestHeader(MissingRequestHeaderException ex) {
        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage("Required request header '" + ex.getHeaderName() + "' is missing");
        errorResponse.setCode("VALIDATION_ERROR");

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

   /* *//**
     * Handles validation errors from @Valid annotation
     *//*
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        String combinedMessage = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.joining(", "));

        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage("Validation failed: " + combinedMessage);
        errorResponse.setCode("VALIDATION_ERROR");

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }*/

    /**
     * Handles ResponseStatusException thrown by Spring controllers.
     * Maps HTTP status codes to appropriate error codes and messages.
     */
    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<ErrorResponse> handleResponseStatusException(ResponseStatusException ex) {
        logger.error(AppLogMessages.RESPONSE_STATUS_EXCEPTION, ex.getStatusCode().value(), ex);
       
        HttpStatus status = HttpStatus.valueOf(ex.getStatusCode().value());
        ErrorResponse errorResponse = buildError(status, ex.getReason());
       
        return ResponseEntity.status(status).body(errorResponse);
    }

    /**
     * Handles BaseException for all business logic.
     * Maps HTTP status codes to appropriate error codes and messages.
     */
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBaseException(BaseException ex) {
        logger.error(AppLogMessages.RESPONSE_STATUS_EXCEPTION, ex.getCode(), ex);

        HttpStatus status = ex.getHttpStatus();
        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setCode(ex.getCode());
        errorResponse.setMessage(ex.getMessage());
//        ErrorResponse errorResponse = buildError(status, ex.getMessage());

        return ResponseEntity.status(status).body(errorResponse);
    }
 
    /**
     * Handles validation errors from @Valid annotation.
     * Collects field-level validation errors and returns detailed error information.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        logger.error(AppLogMessages.VALIDATION_EXCEPTION, ex.getBindingResult().getFieldErrorCount(), ex);

        String combinedMessage = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError ->
                        fieldError.getField().substring(fieldError.getField().lastIndexOf('.') + 1)
                                + " " + fieldError.getDefaultMessage()
                )
                .distinct()
                .collect(Collectors.joining(", "));

        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage(ErrorMessages.VALIDATION_FAILED + " -> " + combinedMessage);
        errorResponse.setCode("VALIDATION_ERROR");
       
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
 
    /**
     * Handles all other unexpected exceptions.
     * Logs the full exception stack trace and returns a generic error response.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        logger.error(AppLogMessages.UNEXPECTED_ERROR, ex.getClass().getSimpleName(), ex);

        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage(ErrorMessages.VALIDATION_FAILED);
        errorResponse.setCode("VALIDATION_ERROR");
       
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
 
    /**
     * Builds a standardized error response based on HTTP status.
     * Maps common HTTP statuses to specific error codes and messages.
     *
     * @param status HTTP status code
     * @param reason Exception reason message
     * @return Formatted Error object
     */
    private ErrorResponse buildError(HttpStatus status, String reason) {
        String code;
        String message;
       
        switch (status) {
            case BAD_REQUEST:
                code = "BAD_REQUEST";
                message = reason != null ? reason : "Bad request";
                break;
            case NOT_FOUND:
                code = "NOT_FOUND";
                message = reason != null ? reason : ErrorMessages.MERCHANT_NOT_FOUND;
                break;
            case INTERNAL_SERVER_ERROR:
                code = "INTERNAL_ERROR";
                message = reason != null ? reason : ErrorMessages.INTERNAL_SERVER_ERROR;
                break;
            case GATEWAY_TIMEOUT:
                code = "TIMEOUT";
                message = reason != null ? reason : ErrorMessages.REQUEST_TIMEOUT;
                break;
            default:
                code = "ERROR";
                message = reason != null ? reason : "An error occurred";
        }

        ErrorResponse errorResponse = new ErrorResponse();
        errorResponse.setMessage(message);
        errorResponse.setCode(code);

        return errorResponse;
    }
}
